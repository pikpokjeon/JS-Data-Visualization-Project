
# Chart 프로젝트가 리팩토링이 필요한 이유
- 공유하는 상태 데이터의 흐름을 추적하기 힘들다
- 해당 데이터의 변화에 따른 메서드의 호출를 명확히 파악하기 힘들다
- SVG 요소를 여러번 수정해야하는 경우 하드코딩을 하고 있다 
- 함수표현문의 사용이 잦다 
- 한 함수에 변수 사용이 잦으며, 재사용 되지않는 부분은 낭비적이다
- 이벤트가 발생 하였을 때, 실행 되는 함수들이 동기적으로 이뤄지지 않는다
- 초기 파라메터와 각 함수들이 가지는 파라메터 수와 크기가 너무 크다
- 불필요한 반복문과 조건문이 많다
- 재사용 되는 코드들이 있다 (문)

## 리팩토링 계획
- 공통적으로 접근해야하는 데이터를 관리하기 위해 PubSub 패턴을 사용한 스토어 함수를 만든다 (후술)
- 필요한 돔 요소들을 생성하는 함수를 각 요소마다 생성하고 트리구조를 짤 수 있게 직관적인 함수 구조를 만든다
- SVG 요소의 변화에 순서가 있다면 순서에 따른 함수의 동기호출이 이뤄지도록 한다
- 데이터 변화값을 다중 함수에서 사용한다면, 파이프라인을 사용한다
- 동일한 성질의 함수를 객체에 담는다
- 커링 함수에 필요한 props 데이터를 미리 담아둔 배열을 생성 해둔다
- 변수에 값을 할당하여 연산을 하기보다, 고차함수로 최종값을 연산 하도록 라이브러리를 구성한다
- 순차적으로 함수를 호출하기 위해, 파이프라인을 사용한다. (동기식/ 비동기식)
- 각 커링함수에 필요한 기본 props를 객체에 정리하고 크기를 최소화한다
- 조건분기는 판별값이 명확할 때 사용한다.
- 반복문은 리턴이 필요한지, 반복문을 사용해 얻을 최종결과를 고려해 for문, 재귀, forEach, map, reduce ... 적재적소에 사용한다
- 상수 값은 별도로 객체에(대문자) , 상태 값은 스토어에 담고 나머지는 프롭스로 내려준다.
- 함수 내에 문을 줄이고 식을 사용하자.


---
## Pub/sub 서비스 ? 
- 메시지 전송자(Publisher)가 메시지 수신자(Subscriber)와 분리되는 메시징 서비스

1. Publisher (pub/sub 서비스 주제 생성) publisher messages a topic to  subscriber (might via broker)
- 중간매개를 두고, 구독함수에 토픽을 전달한다.

3. Topic: Message (페이로드/컨텐츠설명하는 속성) 
- 상태값/상수값 을 가진 객체 ( 토픽, 데이터)

5. MessageStorage filtered with topic/path (메시지는 구독자가 메시지를 소비할 때까지 구독에 보관)
- 스토어, 각 토픽마다 구독자를 보관한다. (저장 순서가 중요하다)

7. Subscribe (target to assign message, message)
- 각 토픽을 구독할 함수들을 저장한다

9. Subscriber (target : 수신된 메세지에 확인 (Ack)) receives subscription 
- 각 토픽에 담긴 구독 함수배열 순서에 따라 토픽을 파이프라인으로 받아서 상태를 사용한다
- 토픽을 받았는지 상태를 확인한다 -> Ack()

10. dispatch
- 구독자들에게 토픽을 건내주도록 이벤트를 호출한다. dispatch()




# 차트 리팩토링
```
    1. 차트 옵션에서 함수가 필요한 부분을 나눈다
    - 차트 생성에 필요한 요소들
    - 차트에 필요한 이벤트
    - x/y 축 좌표 계산하는 함수
    ```

    ```
    2. 차트 생성에 필요한 요소들을 분류한다
    https://developer.mozilla.org/ko/docs/Web/SVG/Element

    (1) 한번만 렌더링 되는지/ 지속적으로 특정 조건하에 렌더링 되는지
    (2) 한 요소가 여러개 생성되어야 하는지

    - 컨테이너
    - 필터
    - 그래픽/ 모양 : 원, 사각형, 선, 패스, 텍스트
    - 그라디언트
    - 스크립트 필터 등등 ..
    ```

    ```
    3. 요소들을 생성하는 함수
    - 초기 속성이 적용된 요소 생성
    - 요소들에 속성을 동적으로 적용
    - 요소를 반복적으로 생성
    - 요소를 동적으로 생성( 업데이트)
    - 요소들을 결합하여, 형태를 구성하기 위한 함수 (그라데이션/ 배경자르기)
    ```

    ```
    4. 요소들로 트리를 구성하고 렌더링하는 함수
    - 요소들로 만들 수 있는 형태 트리 구조로 만들고
    - 사용자 입력값에 따른 전체 비율과 좌표값 연산
    - 필요한 부분에 해당 트리를 확장 가능하도록
    - 완성된 트리를 렌더링 (차트 init)
    ```


## Chart 프로젝트가 리팩토링이 필요한 이유
- 공유하는 동적 데이터의 흐름을 추적하기 힘들다
- 해당 데이터의 변화에 따른 메서드의 호출를 명확히 파악하기 힘들다
- SVG 요소를 여러번 수정해야하는 경우 하드코딩을 하고 있다

## 리팩토링 계획
- 공통적으로 접근해야하는 데이터를 관리하기 위해 PubSub 패턴을 사용하여 데이터를 생성하는 주체와 사용하는 주체를 분리하여 관리
- SVG 요소를 변화 해야하는 경우, 예정된 변화될 요소들을 그룹화하고 적용하는 함수 생성
- SVG 요소의 변화에 순서가 있다면 순서에 따른 동기식 적용 호출 함수 생성

## Pub/sub 서비스 ? 
- 메시지 전송자(Publisher)가 메시지 수신자(Subscriber)와 분리되는 메시징 서비스
```
상에서 하로 진행, 한가지 주제에 일대다 다대일 다대다 관계 성립가능.
1. Publisher (pub/sub 서비스 주제 생성) 데이터를 생성하고 구독권을 생성
3. Message (페이로드/컨텐츠설명하는 속성) 
4. MessageStorage filtered with topic/path (데이터 저장소)
5. Subscription (target to assign message, message- 토픽으로 구분)
6. Subscriber (target : 수신된 메세지에 확인 (Ack/Notify)을 통해 구독하는 데이터 수신 업데이트) 
```
#### SVG 라이브러리 구조
- Topic 메세지(상태)를 관리하는 스토어 (MessageStorage)
- svg 요소와 사용자 입력데이터에 대한 주제
- 새로운 메세지를 생성하는 메서드 (Publisher) 주체
- 발행된 메세지가 가공되 이동하는 파이프라인 ->  Subscriber로 이동
- Subscriber가 메세지를 수신하면, 승인 (update)를 진행
